#### 简单1-1

1. 从输入一个URL 地址到浏览器完成渲染的整个过程

   ###### `简单作答`

   - 浏览器地址栏输入URL 并回车

   - 浏览器查找当前URL 是否存在缓存，并比较缓存是否过期

   - DNS 解析 URL 对应的IP

   - 根据IP 建立TCP 链接（三次握手）

   - 发送http 请求

   - 服务器处理请求，浏览器接受HTTP 响应

   - 浏览器解析并渲染页面

   - 关闭TCP 链接（四次握手）

     ```
     注意！ 面试官可以基于这道题进行前端很多知识点的考察 从http 网络知识到浏览器原理再到前端性能优化 这个题目都可以作为引子开始
     ```

     

   ##### `具体细节`

   - DNS解析：

   DNS解析实际上就是寻找你所需要的资源的过程。假设你输入`www.baidu.com`，而这个网址并不是百度的真实地址，互联网中每一台机器都有唯一标识的IP地址，这个才是关键，但是它不好记，乱七八糟的一串数字，所以就需要一个网址和IP地址的转换，也就是DNS解析。下面看看具体的解析过程：

   ##### 具体解析

   DNS解析其实是一个递归的过程![image-20210909104127659](/Users/a/Library/Application Support/typora-user-images/image-20210909104127659.png)

   输入`www.google.com`网址后，首先在本地的域名服务器中查找，没找到去根域名服务器查找，没有再去com顶级域名服务器查找，...如此类推下去，直接找到IP地址，然后把它记录在本地，供下次使用。大致过程就是`. -> .com -> google.com. -> www.google.com`。（你可能觉得我多写`.`， 并没有，这个`.` 对应的就是根域名服务器，默认情况下所有的网址的最后一位都是`.`，既然是默认情况下，为了方便用户，通常都会省略，浏览器再请求DNS的时候会自动加上）

   ##### DNS优化

   既然已经懂得了解析的具体过程，我们可以看到上述经过N个过程，每个过程有一定的消耗和时间的等待，因此我们得想办法解决一下这个问题！

   ##### DNS缓存

   DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

   1. 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。
   2. 系统缓存主要存在etc/hosts（Linux系统）中

    #####   DNS负载均衡

   不知道你们有没有注意这样一件事，当访问baidu.com的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，假设只有一个服务器，那它的性能和存储量要多大次啊能支撑这样大量的访问呢？DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地址位置的距离等等，这种过程就是DNS负载均衡。

   ##### 发起TCP链接

   TCP提供一种可靠的传输，这个过程涉及到三次握手，四次挥手，下面为哦们你详细看看TCP提供有一种面向连接的，可靠的字节流服务。其首部的数据格式如下

   ![image-20210909140953529](/Users/a/Library/Application Support/typora-user-images/image-20210909140953529.png)

   

   ###### 字段分析

   -  源端口： 源端口和IP地址的作用是标识报文的返回地址。

   - 目的端口： 端口指接收方计算机上的应用程序接口

     ```
     TCP报头中的源端口号和目的端口号IP数据报中的源IP与目的IP唯一确定一条TCP连接。
     ```

   - 序号： 是TCP可靠传输的关键部分。序号是该报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节都有一个序号。比如一个报文段的序号为300，报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性
   - 确认号：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误 的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志为0.
   - 部首长度/数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8=60，故报头的最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区再报文段中的起始偏移值。
   - 保留：占6位，保留今后使用，但目前应都位0。
   - 控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。
     - 紧急URG： 当URG = 1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据
     - 确认ACK： 仅当ACK = 1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1。
     - 推送PSH：当两个应用进程进行交互式通信时，有时在一端的应用进程希望再键入一个命令后立即就能收到对方的响应，这时候就将PSH=1.
     - 复位RST：当RST=1，表明TCP连接中出现了严重差错，必须释放链接，然后再重新建立链接。
     - 同步SYN：在连接建立时用来同步序号。当SYN = 1，ACK = 0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN = 1， ACK = 1。
     - 终止FIN：用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放。

   - 窗口：滑动窗口大小，用来告知发送端接收端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535.

   - 校验和：奇偶校验，此校验和是对整个TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。由发送端计算和存储，并由接收端进行验证。

   - 紧急指针：只有当URG标志置1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段 中的值想加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。

   - 选项和填充：最常见的可选 字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位整数倍，所以要加填填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。

   - 数据部分：TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。

     ```
     📢需要注意的是：（A）不要将确认序号Ack与标志位中的ACK搞混了。（B）确认方Ack=发起方Req+1，两段配对。
     ```

     ##### 三次握手

     ###### 第一次握手：

     客户端发送syn包（Seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认；

     ###### 第二次握手：

     服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

     ###### 第三次握手

     客户端收到服务器的SYN+ACK包，向服务器发送确认ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

     握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才能正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。

     ![image-20210909170510342](/Users/a/Library/Application Support/typora-user-images/image-20210909170510342.png)

     为什么会采用三次握手，若采用二次握手可以吗？四次呢？

     建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。

     采用三次握手是为了防止失效的连接请求报文突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以及是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直再等待主机A发送数据，导致主机B的资源浪费。

     采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。而在三次握手中，client和server都有一个发syn和收ack的过程，双方都是发后能收，表明通信则准备工作OK。

     为什么不是四次握手呢？大家应该知道通信中著名的蓝军红军约定，这个例子说明，通信不可能100%可靠，而上面的三次握手已经做好了通信的准备工作，再增加握手，并不能显著提高可靠性，而且也没有必要。

     ##### 四次挥手

     数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，假设客户端主动关闭，服务器被动关闭。

     ![image-20210909171825286](/Users/a/Library/Application Support/typora-user-images/image-20210909171825286.png)

     

     

     